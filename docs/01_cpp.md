# C++项目中的一些思考

## 头文件

1. 头文件循环包含

为避免头文件被循环包含，一般采用宏来控制，使用以下代码：

```cpp
#ifndef XXX_H
#define XXX_H

// code

#endif // XXX_H
```

还可以使用`#pragma once`来完成，但是这个是跟编译器相关的，推荐上面的方式

2. c 和 c++的一些头文件

比如：

- #include <stdlib.h>
- #include <cstdlib>

两个头文件<stdlib.h>和<cstdlib>实际上是相同的，它们都是 C 语言和 C++语言中用于定义一些常用函数、宏和类型的标准库头文件。

<cstdlib>是 C++标准库的头文件，而<stdlib.h>是 C 语言标准库的头文件。虽然它们提供的函数和宏基本相同，但是在 C++中，<cstdlib>头文件中的函数和宏都位于 std 命名空间中。因此，如果你使用 C++语言，应该使用<cstdlib>头文件，然后在代码中使用 std 命名空间，例如使用 std::malloc()来调用 malloc 函数。

在 C 语言中，<stdlib.h>头文件中的函数和宏不在任何命名空间中，直接使用即可，例如使用 malloc()来调用 malloc 函数。

从这个示例也可以看出，C 语言的库一般都是带有.h 的，而 C++的库一般不带有。

3. Windows 和 Linux 的一些头文件

比如：

- #include <windows.h>
- #include <unistd.h>

因为 sleep 函数在不同的操作系统上有不同的实现和库包含方式。Linux 下甚至没有包含任何头文件，就可以使用；但是 Windows 的行为不同，需要包含头文件，并且\_sleep()的用法已经不支持，目前使用 Sleep()函数，其中的单位是毫秒。

## 库文件

1. 动态库与静态库

作为一个推理框架，提供给用户的应该是一个简单、高效的 SDK，通常的 C++项目 SDK 包含头文件、库文件、以及文档等。这里专门讲一下如何提供库文件，一般来讲，我们追求代码高内聚、低耦合，也就是分开编译不同的模块，但是提供给用户的库应该是唯一的，所以需要额外操作将这些模块合成一个库；其次相比较于静态库，更推荐动态库。

例如将`operator`编译成一个库，如果是静态库，就不需要处理与其他模块的依赖关系，如果是动态库，就需要使用`target_link_libraries(operator xxx)`来链接`operator`所依赖的其他模块，否则就会有链接问题，提示找不到某些符号。

最终提供的编译产物应该是唯一的库，所以需要将各个模块都进行链接，静态库使用`add_dependencies`，动态库使用`target_link_libraries`，最终都链接到一个最终的库上面。

2. 源文件编译的理解

在编译时，会将 cc/cpp 源文件编译为 o 目标文件，这个过程包含了预编译，编译，汇编的步骤，之后将很多个 o 目标文件，链接为 so 或者 a 的库文件；如果 o 文件中有重复定义的符号（symbol），那么就会在链接时期报错。下面仔细思考一下源文件究竟编译了哪些内容：

- 引入头文件就是把头文件复制过去，头文件引入的其他头文件也会一直按照依赖关系复制到当前源文件中，所以有可能出现循环引用，这时候就需要使用宏保护或者利用编译器的特性（#pragma once）
- 把头文件的内容复制过去，和在源文件中【声明】类是一样的，所以可以将类声明写在源文件，起到的作用是一样的，但是为了不在多个源文件中写一样的代码，会单独写在头文件中
- 区分变量、函数、类的声明、定义和实现：一般声明在头文件中，不分配内存；定义和实现（定义里面的具体操作就是实现，所以可以认为这 2 个概念相同），一般在源文件中，会分配内存
- 如果在头文件中对变量定义，那么不同源文件就定义了相同的符号，不同 o 目标文件中就会出现相同的符号，导致链接错误
- 经过实验：一个头文件的声明在源文件不实现，源文件引用此头文件，里面的符号也不会被编译

3. 编译产物的理解

将不同的模块解耦是一种好的设计方式，这里提到的解耦，就是不将全部的源文件编译为一个 so，而是分成几个不同的 so；so 里面是符号表，也就是源码中的函数等，被编译到 so 中，然后被其他模块使用。

使用的方法是：

- 引入头文件，得到对应的符号的声明，然后如果有文件中没有实现，那么就需要显式的链接 so，寻找实现
- 引入头文件，头文件包含了实现，就不需要链接了，即使主动声明链接关系，也不会真的建立

那么，在编译时指定的源文件，如果不停的引入头文件，那么就不断地将其他的头文件复制到源文件处，这里可能会有其他模块的头文件；但是不要紧，这样的链接关系只会增加一些代码，而不会破坏之前的解耦结果；另一种情况是，头文件中包含了实现，那么尽管头文件在某一个目录下，但实际上这里的代码已经被编译到了引用此头文件的模块中。

## C++的特性

1. 虚函数的使用

首先说一下继承的应用场景，某个时候新建对象，但不能确定新建对象的类型时，可以使用统一的父类指针接收这个对象；在实际使用时，调用某个方法（子类和父类都实现了）：

- 父类未声明虚函数，则由于此时是父类指针，所以会走父类的方法
- 父类声明虚函数，并实现，会根据具体对象的类型，判断走哪个方法
- 父类声明纯虚函数，则不会实现，此时一定走子类的方法

2. 模板的使用

使用模板函数的时候，要在头文件中实现。模板函数的实现需要在编译时可见，因为编译器需要根据具体的模板参数生成代码。如果你把模板函数的实现放在`.cpp`文件中，那么在编译其他文件时，编译器就无法看到模板函数的实现，因此会导致链接错误。

3. 内存泄漏

debug 到一定程度就会关注这个问题，除了用肉眼观察以外，还有一些工具可以帮忙：

1. Valgrind（sudo apt install valgrind）：valgrind --leak-check=full ./gtest-main
2. AddressSanitizer（ASan）：g++ -fsanitize=address -g -o your_program your_program.cpp
3. Dr. Memory：drmemory -- your_program
4. 静态分析工具：sudo apt install cppcheck/clang-tidy

5. cpp 版本

命令行：

```sh
g++ -dM -E -x c++ /dev/null | grep __cplusplus
clang++ -dM -E -x c++ /dev/null | grep __cplusplus
```

编译源文件查看：

```cpp
#include <iostream>

int main() {
    if (__cplusplus == 202002L) {
        std::cout << "C++20" << std::endl;
    } else if (__cplusplus == 201703L) {
        std::cout << "C++17" << std::endl;
    } else if (__cplusplus == 201402L) {
        std::cout << "C++14" << std::endl;
    } else if (__cplusplus == 201103L) {
        std::cout << "C++11" << std::endl;
    } else if (__cplusplus == 199711L) {
        std::cout << "C++98" << std::endl;
    } else {
        std::cout << "Unknown C++ standard: " << __cplusplus << std::endl;
    }
    return 0;
}
```

## 格式化

考虑clang-format

```sh
# 安装LLVM自动带有clang-format

# 在cmake中构建为目标，就不用复杂的命令去抓取repo下的全部cpp文件了
cmake -B build -S .
cmake --build build --target format

# 单独的文件
clang-format -style=google -i main.cc
```